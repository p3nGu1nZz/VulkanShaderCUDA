#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

layout(push_constant) uniform Constants {
    uint width;
    uint height;
    uint channels;
    uint batch_size;
    uint kernel_size;
    uint stride;
} params;

void main() {
    uint output_x = gl_GlobalInvocationID.x;
    uint output_y = gl_GlobalInvocationID.y;
    uint channel = gl_GlobalInvocationID.z % params.channels;
    uint batch = gl_GlobalInvocationID.z / params.channels;
    
    uint output_width = (params.width - params.kernel_size) / params.stride + 1;
    uint output_height = (params.height - params.kernel_size) / params.stride + 1;
    
    if (output_x >= output_width || output_y >= output_height || 
        batch >= params.batch_size || channel >= params.channels) {
        return;
    }
    
    float max_val = -3.402823466e+38;  // FLT_MIN
    
    // Input starting position
    uint start_x = output_x * params.stride;
    uint start_y = output_y * params.stride;
    
    // Pooling window
    for (uint ky = 0; ky < params.kernel_size; ky++) {
        for (uint kx = 0; kx < params.kernel_size; kx++) {
            uint input_x = start_x + kx;
            uint input_y = start_y + ky;
            
            if (input_x < params.width && input_y < params.height) {
                uint input_idx = 
                    batch * params.height * params.width * params.channels +
                    input_y * params.width * params.channels +
                    input_x * params.channels +
                    channel;
                    
                max_val = max(max_val, input_buf.data[input_idx]);
            }
        }
    }
    
    uint output_idx = 
        batch * output_height * output_width * params.channels +
        output_y * output_width * params.channels +
        output_x * params.channels +
        channel;
        
    output_buf.data[output_idx] = max_val;
}