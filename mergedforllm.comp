// add.comp
#version 450
layout(local_size_x = 256) in;

layout(binding = 0) buffer InputA {
    float data[];
} inputA;

layout(binding = 1) buffer InputB {
    float data[];
} inputB;

layout(binding = 2) buffer Output {
    float data[];
} outputC;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    outputC.data[idx] = inputA.data[idx] + inputB.data[idx];
}

// add_grad.comp
#version 450
layout(local_size_x = 256) in;

layout(binding = 0) buffer GradOutput {
    float data[];
} gradOut;

layout(binding = 1) buffer GradA {
    float data[];
} gradA;

layout(binding = 2) buffer GradB {
    float data[];
} gradB;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    float grad = gradOut.data[idx];
    gradA.data[idx] = grad; // ∂L/∂a = grad
    gradB.data[idx] = grad; // ∂L/∂b = grad
}

// conv2d.comp
#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) readonly buffer Kernel {
    float data[];
} kernel_buf;

layout(binding = 2) writeonly buffer Output {
    float data[];
} output_buf;

layout(push_constant) uniform constants {
    uint inputWidth;
    uint inputHeight;
    uint inputChannels;
    uint outputChannels;
    uint kernelSize;
} params;

void main() {
    uint outX = gl_GlobalInvocationID.x;
    uint outY = gl_GlobalInvocationID.y;
    uint outChannel = gl_GlobalInvocationID.z;

    uint outputWidth = params.inputWidth - params.kernelSize + 1;
    uint outputHeight = params.inputHeight - params.kernelSize + 1;

    if (outX >= outputWidth || outY >= outputHeight || outChannel >= params.outputChannels) {
        return;
    }

    float sum = 0.0;

    for (uint ic = 0; ic < params.inputChannels; ic++) {
        for (uint ky = 0; ky < params.kernelSize; ky++) {
            for (uint kx = 0; kx < params.kernelSize; kx++) {
                uint inX = outX + kx;
                uint inY = outY + ky;

                uint inIdx = (inY * params.inputWidth + inX) * params.inputChannels + ic;
                uint kernelIdx = ((outChannel * params.inputChannels + ic) * params.kernelSize + ky) * params.kernelSize + kx;

                sum += input_buf.data[inIdx] * kernel_buf.data[kernelIdx];
            }
        }
    }

    uint outIdx = (outY * outputWidth + outX) * params.outputChannels + outChannel;
    output_buf.data[outIdx] = sum;
}

// matmul.comp
#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer InputA {
    float data[];
} inputA;

layout(binding = 1) buffer InputB {
    float data[];
} inputB;

layout(binding = 2) buffer Output {
    float data[];
} outputC;

layout(push_constant) uniform Constants {
    uint M;  // Height of A
    uint K;  // Width of A / Height of B
    uint N;  // Width of B
} params;

shared float tileA[16][16];
shared float tileB[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;

    float sum = 0.0;

    uint numTiles = (params.K + 15) / 16;

    for (uint t = 0; t < numTiles; t++) {
        // Load A tile
        uint aRow = row;
        uint aCol = t * 16 + localCol;
        if (aRow < params.M && aCol < params.K) {
            tileA[localRow][localCol] = inputA.data[aRow * params.K + aCol];
        } else {
            tileA[localRow][localCol] = 0.0;
        }

        // Load B tile
        uint bRow = t * 16 + localRow;
        uint bCol = col;
        if (bRow < params.K && bCol < params.N) {
            tileB[localRow][localCol] = inputB.data[bRow * params.N + bCol];
        } else {
            tileB[localRow][localCol] = 0.0;
        }

        barrier();

        // Compute dot product for this tile
        for (uint k = 0; k < 16; k++) {
            sum += tileA[localRow][k] * tileB[k][localCol];
        }

        barrier();
    }

    if (row < params.M && col < params.N) {
        outputC.data[row * params.N + col] = sum;
    }
}

// matmul_grad.comp
#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer GradOutput {
    float data[];
} gradOut;

layout(binding = 1) buffer InputA {
    float data[];
} inputA;

layout(binding = 2) buffer InputB {
    float data[];
} inputB;

layout(binding = 3) buffer GradA {
    float data[];
} gradA;

layout(binding = 4) buffer GradB {
    float data[];
} gradB;

layout(push_constant) uniform PushConstants {
    uint M;
    uint K;
    uint N;
} pc;

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    if (row >= pc.M || col >= pc.N) return;
    float grad = gradOut.data[row * pc.N + col];
    
    // ∂L/∂a = grad * B
    for (uint k = 0; k < pc.K; ++k) {
        gradA.data[row * pc.K + k] += grad * inputB.data[k * pc.N + col];
    }
    
    // ∂L/∂b = grad * A
    for (uint k = 0; k < pc.K; ++k) {
        gradB.data[k * pc.N + col] += grad * inputA.data[row * pc.K + k];
    }
}

// mergedforllm.comp

// mul.comp
#version 450

layout(local_size_x = 256) in;

layout(binding = 0) buffer InputA { float a[]; };
layout(binding = 1) buffer InputB { float b[]; };
layout(binding = 2) buffer OutputC { float c[]; };

void main() {
    uint idx = gl_GlobalInvocationID.x;
    c[idx] = a[idx] * b[idx];
}

// pooling.comp
#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

layout(push_constant) uniform Constants {
    uint width;
    uint height;
    uint depth;
    uint poolSizeX;
    uint poolSizeY;
} params;

void main() {
    uint outX = gl_GlobalInvocationID.x;
    uint outY = gl_GlobalInvocationID.y;
    uint channel = gl_GlobalInvocationID.z;

    if (outX >= params.width / params.poolSizeX || outY >= params.height / params.poolSizeY || channel >= params.depth) {
        return;
    }

    float maxValue = -3.402823466e+38;

    for (uint py = 0; py < params.poolSizeY; py++) {
        for (uint px = 0; px < params.poolSizeX; px++) {
            uint inX = outX * params.poolSizeX + px;
            uint inY = outY * params.poolSizeY + py;

            if (inX < params.width && inY < params.height) {
                uint inIdx = (inY * params.width + inX) * params.depth + channel;
                maxValue = max(maxValue, input_buf.data[inIdx]);
            }
        }
    }

    uint outIdx = (outY * (params.width / params.poolSizeX) + outX) * params.depth + channel;
    output_buf.data[outIdx] = maxValue;
}

// relu.comp
#version 450
layout(local_size_x = 256) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= input_buf.data.length()) {
        return;
    }
    float val = input_buf.data[idx];
    output_buf.data[idx] = max(0.0, val);
}

// sigmoid.comp
#version 450
layout(local_size_x = 256) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= input_buf.data.length()) {
        return;
    }
    float x = input_buf.data[idx];
    output_buf.data[idx] = 1.0 / (1.0 + exp(-x));
}

// softmax.comp
#version 450
layout(local_size_x = 256) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

shared float local_max;
shared float local_sum;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint local_idx = gl_LocalInvocationID.x;

    if (idx >= input_buf.data.length()) return;

    // Step 1: Compute maximum for numerical stability
    float val = input_buf.data[idx];
    local_max = max(val, local_max);
    barrier();

    // Step 2: Compute exponentials and sum
    float exp_val = exp(val - local_max);
    local_sum += exp_val;
    barrier();

    // Step 3: Normalize
    output_buf.data[idx] = exp_val / local_sum;
}

