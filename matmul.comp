// matmul.comp
#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer InputA {
    float data[];
} inputA;

layout(binding = 1) buffer InputB {
    float data[];
} inputB;

layout(binding = 2) buffer Output {
    float data[];
} outputC;

layout(push_constant) uniform Constants {
    uint M;  // Height of A
    uint K;  // Width of A / Height of B
    uint N;  // Width of B
} constants;

shared float sharedA[16][16];  // Tile size = 16x16
shared float sharedB[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;

    float sum = 0.0;
    
    // Number of tiles needed
    uint numTiles = (constants.K + 15) / 16;

    // Process each tile
    for (uint tile = 0; tile < numTiles; tile++) {
        // Load data into shared memory
        uint tileOffset = tile * 16;
        
        // Load A into shared memory
        if ((row < constants.M) && (tileOffset + localCol < constants.K)) {
            sharedA[localRow][localCol] = inputA.data[row * constants.K + tileOffset + localCol];
        } else {
            sharedA[localRow][localCol] = 0.0;
        }
        
        // Load B into shared memory
        if ((tileOffset + localRow < constants.K) && (col < constants.N)) {
            sharedB[localRow][localCol] = inputB.data[(tileOffset + localRow) * constants.N + col];
        } else {
            sharedB[localRow][localCol] = 0.0;
        }
        
        // Ensure all threads have loaded their data
        barrier();
        
        // Compute partial dot product for this tile
        for (uint k = 0; k < 16; k++) {
            sum += sharedA[localRow][k] * sharedB[k][localCol];
        }
        
        // Ensure all threads are done with shared memory
        barrier();
    }

    // Write result
    if (row < constants.M && col < constants.N) {
        outputC.data[row * constants.N + col] = sum;
    }
}