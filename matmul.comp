#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer InputA {
    float data[];
} inputA;

layout(binding = 1) buffer InputB {
    float data[];
} inputB;

layout(binding = 2) buffer Output {
    float data[];
} outputC;

layout(push_constant) uniform Constants {
    uint M;  // Height of A
    uint K;  // Width of A / Height of B
    uint N;  // Width of B
} params;

shared float tileA[16][16];
shared float tileB[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;

    float sum = 0.0;

    uint numTiles = (params.K + 15) / 16;

    for (uint t = 0; t < numTiles; t++) {
        // Load A tile
        uint aRow = row;
        uint aCol = t * 16 + localCol;
        if (aRow < params.M && aCol < params.K) {
            tileA[localRow][localCol] = inputA.data[aRow * params.K + aCol];
        } else {
            tileA[localRow][localCol] = 0.0;
        }

        // Load B tile
        uint bRow = t * 16 + localRow;
        uint bCol = col;
        if (bRow < params.K && bCol < params.N) {
            tileB[localRow][localCol] = inputB.data[bRow * params.N + bCol];
        } else {
            tileB[localRow][localCol] = 0.0;
        }

        barrier();

        // Compute dot product for this tile
        for (uint k = 0; k < 16; k++) {
            sum += tileA[localRow][k] * tileB[k][localCol];
        }

        barrier();
    }

    if (row < params.M && col < params.N) {
        outputC.data[row * params.N + col] = sum;
    }
}
