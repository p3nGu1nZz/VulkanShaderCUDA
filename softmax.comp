#version 450
#extension GL_EXT_shader_atomic_float : enable
#extension GL_EXT_shader_atomic_float2 : enable

layout(local_size_x = 256) in;

layout(binding = 0) readonly buffer Input {
    float data[];
} input_buf;

layout(binding = 1) writeonly buffer Output {
    float data[];
} output_buf;

layout(push_constant) uniform Constants {
    uint size;
} params;

shared float shared_max;
shared float shared_sum;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationID.x;
    uint local_size = gl_WorkGroupSize.x;
    
    // Initialize shared memory
    if (lid == 0) {
        shared_max = -3.402823466e+38;  // FLT_MIN
        shared_sum = 0.0;
    }
    barrier();
    
    // Step 1: Find maximum value for numerical stability
    float thread_max = -3.402823466e+38;
    for (uint i = gid; i < params.size; i += gl_NumWorkGroups.x * local_size) {
        thread_max = max(thread_max, input_buf.data[i]);
    }
    
    // Reduce to find global max
    atomicMax(shared_max, thread_max);
    barrier();
    
    // Step 2: Compute exp(x - max) and sum
    float thread_sum = 0.0;
    for (uint i = gid; i < params.size; i += gl_NumWorkGroups.x * local_size) {
        float val = exp(input_buf.data[i] - shared_max);
        thread_sum += val;
        // Store intermediate exp values
        output_buf.data[i] = val;
    }
    
    // Reduce to find global sum
    atomicAdd(shared_sum, thread_sum);
    barrier();
    
    // Step 3: Normalize by sum
    for (uint i = gid; i < params.size; i += gl_NumWorkGroups.x * local_size) {
        output_buf.data[i] /= shared_sum;
    }
}
